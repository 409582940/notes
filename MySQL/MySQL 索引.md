索引的出现就是为了解决查询效率的问题，它相当于书的目录。本身就是一种特殊的数据结构
## 索引的优点：
- 将随机IO变成顺序IO
- 减少了需要扫描的数据量
- 帮助服务器避免排序和临时表
## 索引的缺点：
- 创建维护索引需要消耗额外的时间和空间(InnoDB上面的索引是表空间的额外组成部分)。
- 当进行增删改的操作时需要动态的维护索引，降低了效率
## 索引的用处
- 快速查找where语句的行
- 如果表中有多个索引，则优化器可以使用索引的任何最左前缀来查找行
- 当有表连接的时候，从其他表检索行数据
- 查找特定索引列min或者max值
- 如果排序或者分组在可控索引的最左前缀上完成的。则对表进行排序和分组
- 在某些情况下，可以优化查询以检索而无需查询数据行
## 索引的分类：
- 主键索引 
- 唯一索引
- 普通索引
- 全文索引

唯一索引：不允许两行有相同的值（数据列不允许重复，值可以为null，一个表可以有多个唯一索引）

主键索引：使用主键作索引（数据列不允许重复，值不能为null，一个表只能有一个主键）

聚簇索引：简单的理解就是表中的数据和索引是绑定的。表中行的物理顺序和索引的排列顺序一致

非聚簇索引：------

复合索引：在创建索引时候，不止创建一列为索引，创建多个列为索引

全文索引：全文索引在字符串数据进行复杂的查询，一般用的比较少。有相关的需要一般都是使用Elasticsearch

普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。

![](https://raw.githubusercontent.com/409582940/notes/main/images/20220303111217.png)

## 如何评价一个索引是否适合某个查询？
索引将相关的记录放到一起则获得一星；
如果索引中的数据顺序和查找中的排列顺序一致则获得二星；
如果索引中的列包含了查询中需要的全部列则获得三星。
## 索引一定是最好的选择么？
不一定，对于非常小的表的话，全表扫描更加有效。
对于特大型的表，建立和使用索引的代价会随之增加。在这种情况下分区是一种好的选择
如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性
## MySQL索引的数据结构

常用的数据结构一般有B+树，哈希。
B+树适合范围查找，哈希一般应用于等值查找
B+树：一种特殊的n叉树，叶子节点存储值和指向下个节点的指针，非叶子节点保存数据的指针。
### 哈希索引的限制与优势
优势：
1、哈希索引只需要存储对应的哈希值，索引的结构十分的紧凑，查找速度很快
限制：
1、哈希索引数据并不是按照索引值为顺序存储的，无法进行排序
2、哈希索引不支持部分列的匹配查找
3、哈希索引不支持范围查找
4、当哈希冲突比较多的时候，维护的成本比较高；

## InnoDB选择B+树作为默认索引的数据结构原因

可以总结为以下几点：

1、相对哈希来讲，B+树更适合范围查找。因为她增删改查的时间复杂度都是O(logn)的。并且由于b+树的特性，存储的数据天然具有顺序的，并且每一个叶子结点到根节点的距离相等。叶子结点之间有指针进行连接
![](https://raw.githubusercontent.com/409582940/notes/main/images/20220310140619.png)
对于InnoDB引擎来说，有一个特殊的功能叫做自适应哈希索引。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于b+树索引之上在创建一个哈希索引，这样就会让b+树索引也具备一些哈希索引的优点，比如快速的哈希查找

2、相对红黑树来讲。插入或者删除一个元素红黑树都需要重新平衡，这是一个额外的成本。在数据量很大的时候这个耗时会比较长，影响效率

3、相对B树来讲，B+树的查询更稳定，B+树能存储更多的数据，能减少顺序遍历而产生的额外的磁盘IO
## 索引匹配方式
- 全值匹配
全职匹配的是和索引中所有列进行匹配

- 匹配最左前缀
只匹配最前面的几列，即只是使用索引的第一列

- 匹配列前缀
可以匹配某一列值开头的一部分

- 匹配范围值
可以查找一个范围的数据
- 精确匹配某一列或范围匹配另外一列
可以查询第一列的全部和第二列的一部分

- 只访问索引的查询 
查询的时候只访问索引，不访问数据行。本质上就是数据行

## 索引失效情况
1、组合索引不遵循最左匹配原则

2、组合索引的前面索引列使用范围查询(<,>,like),会导致后续的索引失效

3、不要在索引上做任何操作（计算，函数，类型转换）

4、is null和is not null无法使用索引

5、尽量少使用or操作符，否则连接时索引会失效

6、字符串不添加引号会导致索引失效

7、两表关联使用的条件字段中字段的长度、编码不一致会导致索引失效

8、like语句中，以%开头的模糊查询

9、如果mysql中使用全表扫描比使用索引快，也会导致索引失效

## 前缀索引
场景：很长的字符串上建立索引，哈希索引有时候可能还不够。
这个时候就需要前缀索引了，就是选择一部分的字段作为索引，同时，长度的选择会影响索引的性能。因为索引选择性，比如唯一索引的选择性就是1，这个性能是最好的

判断前缀索引的好坏可以使用SQL语句
例如
``` sql
select count(*) as cnt,LEFT(city,3) as pref From .... 
```
或者就是计算列的完整性，并使前缀的选择性接近完整列的选择性
例如
``` sql
select count(DISTINCT city)/COUNT(*) FROM ...
```
通常来说，这个能接近0.031就可以使用了
缺点：
无法使用前缀索引进行`order by`和`group by`
也无法使用前缀索引进行覆盖扫描
## 聚簇索引
聚簇索引不是一种单独的数据类型，而是一种数据的存储方式。在InnoDB中，聚簇索引实际上在同一个结构中保存了B+树索引和数据行。当表中有聚簇索引的时，他的数据行实际上存放在索引的叶子页中。
聚簇索引的每一个叶子节点包含了主键值，事务ID，用于事务的MVCC的回滚指针以及剩余列，如果主键是一个列前缀索引，InnoDB会包含完整的主键列和剩下的其他列
因为无法同时把数据行存放在两个不同的地方，所以一张表只能有一个聚簇索引

不过覆盖索引可以模拟多个聚簇索引的情况

在InnoDB中，它通过主键聚集数据。如果没有主键，会选择一个唯一非空索引代替，如果没有这样的索引，会隐式定义一个主键作为聚簇索引

优点：
1、可以将相关的数据保存在一起。
比如实现电子邮件的功能，可以通过用户ID来聚集数据。如果没有聚簇索引，可能每封邮件都会导致一次磁盘的IO

2、数据访问更快，因为找到相关的索引就找到了数据

3、使用覆盖索引的查询可以直接Q使用叶节点中的主键值
缺点：
1、局促数据最大限度提高了IO密集型应用的性能。如果数据全在内存中，访问顺序就不重要了，聚簇索引也没有了优势

2、插入数据的时候，插入数据的速度严重依赖插入速度，按照主键的顺序是最快的

3、更新聚簇索引的代价很高，因为每一次更新都会强制InnoDB将每个被更新的行移动到新的位置

4、插入数据的时候，或者主键被更新需要移动行的时候可能会造成页分裂
比如当前页已经满了，此时插入就会造成当前页分裂成两个容纳这次操作，页分裂会造成表占用更多的磁盘空间
5、聚簇索引可能导致全表扫描变慢，因为页分裂造成数据存储不连续

6、非聚簇索引需要两次索引查找，不是一次
因为非聚簇索引中叶子结点保存的不是指向行的物理位置的指针，是行的主键值
这意味着非聚簇索引查找航，需要先到叶子结点找到获取对应的主键值，然后根据这个值去聚簇索引中找对应的行。这做了重复的工作，两次B+树的查找，有额外的IO开销
## 按照主键的顺序插入行好处
避免了页分裂
主键是连续的话，InnoDB把每一条记录存贮在上一条记录的后面，当达到最大的填充因子，下一条记录就会写入到新的页中

如果是非连续的主键，因为新行的主键值不一定比之前的大，所以不能简单的插入最后面，每一次都需要找到合适的位置，之后就是分配空间。这是额外的工作

总结下来不按照主键的插入缺点：
1、写入的目标页可能已经刷到磁盘上并从缓存中移除，或者没有加载到缓存中。所以要先将目标页加载到内存中，这是额外的IO消耗

2、写入是乱序的，InnoDB不得不进行频繁的页分裂操作。由于频繁的页分裂，页也会变得稀疏并被不规则填充，最终数据会有碎片
## 顺序的主键插入什么时候会造成更坏的结果
高并发情况下，可能造成间隙锁竞争，还有就是AUTO_INCREMENT锁机制
## 覆盖索引
索引包含了所有需要查询的字段，被称为覆盖索引
优点
1、索引条目通常远小于数据行大小，减少了MySQL的数据访问量

2、索引是按照列值顺序存贮的（至少在单个页是这样的），这样范围查询会比随机从磁盘读取每一行的IO小得多

3、由于InnoDB中的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，如果二级主键能够覆盖查询，可以避免主键索引的二次查询

