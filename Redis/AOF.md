AOF日志，redis两大持久化方式之一
与MySQL的redo log相反的是，AOF日志是写前日志。也就是redis先写入数据库，再写入AOF日志
# 写后日志的原因：

保证命令是正确的，因为写入AOF日志中不会检查语法错误。如果命令不正确，客户端会报错，就不会写入到AOF日志中。还有一个好处就是，不会阻塞当前的操作

不过写后日志也有潜在的问题：如果此时数据库完成写入操作宕机，最后一次操作没有写入到AOF日志中，这样最后一条数据没有办法恢复。同时，写入日志的操作会阻塞下一次写入数据库的操作

为了解决这些潜在的问题，AOF设计了三种写回策略
- **Always** 同步写回
- **Everysec** 每秒写回
- **No** 操作系统控制的写回
优劣如图
![](https://raw.githubusercontent.com/409582940/notes/main/images/20220317104741.png)
# AOF重写
解决了日志文件过大的问题
重写机制实际上就是"多变一"，旧日志的多条命令，在重写后变成一条命令
![](https://raw.githubusercontent.com/409582940/notes/main/images/20220317105225.png)
## 重写会阻塞主线程么？
AOF日志是在主线程写回，重写是在后台线程中写入
重写的过程可以概括为"一个拷贝，两份日志"
- ⼀个拷⻉
每次执⾏重写时，主线程`fork`出后台的`bgrewriteaof`⼦进程。此时，`fork`会把主线程 的内存拷⻉⼀份给`bgrewriteaof`⼦进程，这⾥⾯就包含了数据库的最新数据。然后，`bgrewriteaof`⼦进程就 可以在不影响主线程的情况下，逐⼀把拷⻉的数据写成操作，记⼊重写⽇志。 
- 两处⽇志
因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第⼀处⽇志就是指正在使⽤的AOF⽇志，Redis会把这个操作写到它的缓冲区。这样⼀来，即使宕机了，这个AOF⽇志的操作仍然是⻬全的，可以⽤于恢复。⽽第⼆处⽇志，就是指新的AOF重写⽇志。这个操作也会被写到重写⽇志的缓冲区。这样，重写⽇志也不会 丢失最新的操作。等到拷⻉数据的所有操作记录重写完成后，重写⽇志记录的这些最新操作也会写⼊新的 AOF⽂件，以保证数据库最新状态的记录。此时，我们就可以⽤新的AOF⽂件替代旧⽂件了。
# AOF的底层原理
持久化的实现可以分为三个步骤
- 追加（append）
- 文件写入
- 文件同步(Sync)
